<html5>
  <head>
    <style>
      #pad, button {
        font-size: 16pt;
        font-family: "Monaco";
      }
    </style>
    <script type="text/javascript"
            src='http://code.jquery.com/jquery-1.11.0.min.js'></script>
    <script>

      // initialize state
      window.state = {
        headContent: "",
        commits: [{
          parent: null,
          diff: [],
        }],
        clientID: + new Date(),
        pending: false,
      };

      // creates commit of local changes since last commit, sends to server
      function doCommit() {
        if (window.state.pending) {
          return;
        };
        var oldContent = window.state.headContent;
        var newContent = $("#pad").val();
        if (oldContent == newContent) {
          return;
        }
        window.state.pending = true;
        var diff = getDiff(oldContent, newContent);
        var commit = {
          clientID: window.state.clientID,
          parent: head(),
          diff: diff,
        };
        $("#btnCommit").attr("disabled", "disabled");
        $.ajax({
          url: "/diffs/put",
          data: {
            "doc-id": window.location.pathname,
            "diff": JSON.stringify(commit),
          },
          type: "PUT",
          success: function(resp) {
          },
          error: function(e) {
            console.log("commit", e.responseText);
          }
        });
      }

      // merges in the next change from the server
      function doUpdate() {
        $.ajax({
          url: "/diffs/get",
          data: {
            "doc-id": window.location.pathname,
            "diff-id": head() + 1,
          },
          type: "PUT",
          success: function(resp) {
            var commit = JSON.parse(resp);
            applyCommit(commit);
            $("#btnCommit").removeAttr("disabled");
            doUpdate();
          },
          error: function(e) {
            console.log(e.responseText);
          },
        });
      }

      // creates diff from a -> b
      function getDiff(a, b) {

        var cost = function(ops) {
          var cost = ops.length;
          return cost;
        }

        // perform dynamic program to create diff
        var memo = {}
        // dp(i,j) returns the cost and specific operations to transform
        // a[:i] into b[:j]
        var dp = function(i, j) {
          // check if answer is memoized; if so return it
          var key = i + "," + j;
          if (key in memo) {
            return copy(memo[key])
          }

          // if not compute, store and return it
          var answer;
          if (i == 0 && j == 0) {
            // both documents finished together
            answer = {cost: 0, ops: []};
          } else if (i == 0) {
            // remaining part of b must be inserted at beginning then
            result = dp(i, j-1);
            result.ops.push({
              type: "Insert",
              index: 0,
              val: b[j-1],
            });
            result.cost = cost(result.ops);
            answer = result;
          } else if (j == 0) {
            // remaining part of a must be deleted
            result = dp(i-1, j);
            result.ops.push({
              type: "Delete",
              index: i-1,
            });
            result.cost = cost(result.ops);
            answer = result;
          } else {
            var insertResult = dp(i, j-1);
            insertResult.ops.push({
              type: "Insert",
              index: i,
              val: b[j-1],
            });
            insertResult.cost = cost(insertResult.ops);

            var deleteResult = dp(i-1, j);
            deleteResult.ops.push({
              type: "Delete",
              index: i - 1,
            });
            deleteResult.cost = cost(deleteResult.ops);

            if (insertResult.cost <= deleteResult.cost) {
              answer = insertResult;
            } else {
              answer = deleteResult;
            }

            if (a[i-1] == b[j-1] && dp(i-1,j-1).cost < answer.cost) {
              answer = dp(i-1, j-1);
            }
          }


          memo[key] = answer
          return copy(answer)
        }

        var ops = dp(a.length, b.length).ops;

        // collapse adjacent
        if (ops.length == 0) {
          return []
        }
        var diff = [];
        var runningOp = copy(ops[0]);
        if (runningOp.type == "Delete") {
          runningOp.size = 1;
        }

        for (var i = 1; i < ops.length; i += 1) {
          if (runningOp.type == "Insert" &&
              ops[i].type == "Insert" &&
              ops[i].index == runningOp.index) {
            runningOp.val += ops[i].val;
          } else if (runningOp.type == "Delete" &&
              ops[i].type == "Delete" &&
              ops[i].index == runningOp.index + runningOp.size) {
            runningOp.size += 1;
          } else {
            diff.push(runningOp);
            runningOp = copy(ops[i]);
            if (runningOp.type == "Delete") {
              runningOp.size = 1;
            }
          }
        }
        diff.push(runningOp);
        return diff;
      }

      // applies commit sent by server to the local state, updating UI also.
      function applyCommit(commit) {
        // make this diff relevant for the current HEAD
        var newDiff = commit.diff;
        for (var i = commit.parent + 1; i <= head(); i += 1) {
          newDiff = rebase(window.state.commits[i].diff, newDiff);
        };
        var newCommit = {
          parent: head(),
          diff: newDiff,
        };
        window.state.commits.push(newCommit);
        var oldHeadContent = window.state.headContent;
        var newHeadContent = applyDiff(window.state.headContent, newDiff);

        // check origin of commit
        if (commit.clientID == window.state.clientID) {
          // this is our outstanding commit, so we can actually ignore it! it is
          // accounted for in the live text!
          window.state.pending = false;
        } else {
          // this is an intermediate commit, so we need to rebase all the live
          // changes we've made since the latest commit.
          $("#pad").attr("disabled", "disabled");
          var currentContent = $("#pad").val();
          var localDiff = getDiff(oldHeadContent, currentContent);
          var newLocalDiff = rebase(newDiff, localDiff);
          var newContent = applyDiff(newHeadContent, newLocalDiff);
          $("#pad").val(newContent);
          // unlock UI
          $("#pad").removeAttr("disabled");
        }
        window.state.headContent = newHeadContent;
      }

      // given two diffs to the same document, return a diff2' which captures as
      // many of the changes in diff2 as possible and can be applied to the
      // document + diff1.
      var rebase = function(d1, d2) {

        // cumulative state as we iterate through with two fingers
        var i = 0;
        var j = 0;
        var output = [];
        var shift = 0;

        // possible options at each stage
        var doOldInsert = function() {
          shift += d1[i].val.length;
          i += 1;
        }
        var doOldDelete = function() {
          // we want to ignore any inserts contained strictly in the bounds we
          // also want to ignore any delets contained *strictly* in the bounds
          // we want to modify partially overlapping deletes
          while (j < d2.length && d2[j].index < d1[i].index + d1[i].size) {
            if (d2[j].type == "Insert") {
              // ignore it
            } else if (d2[j].type == "Delete") {
              if (d2[j].index + d2[j].size > d1[i].index + d1[i].size) {
                // delete has mismatched overlap
                // OLD: --[--]--
                // NEW: ---[--]-
                //    : --[-]-
                var op = copy(d2[j]);
                op.index = d1[i].index + shift;
                op.size = d2[j].index + d2[j].size - d1[i].index + d1[i].size;
                output.push(op);
              } else {
                // delete is completely contained, ignore.
              }
            }
            j += 1;
          }
          shift -= d1[i].size;
          i += 1;
        }
        var doNewInsert = function() {
          var op = copy(d2[j]);
          op.index += shift;
          output.push(op);
          j += 1;
        }
        var doNewDelete = function() {
          // we want to adjust this delete's starting index appropriately. we
          // also want to adjust this delete's size based on any ops this delete
          // strictly contains.
          var op = copy(d2[j]);
          op.index += shift;
          var originalSize = op.size;
          while (i < d1.size && d1[i].index < op.index + originalSize) {
            if (d1[i].type == "Insert") {
              // need to increase the size to include this insert
              op.size += d1[i].val.length;
              shift += d1[i].val.length;
            } else if (d1[i].type == "Delete") {
              // need to adjust the size to be up to
              // NEW: --[---]--
              // OLD: ---[-]---
              // OLD: ---[---]-
              var smallerRightBoundary = Math.min(op.index + originalSize,
                                                  d1[i].index + d1[i].size);
              op.size -= smallerRightBoundar - d1[i].index;
              shift -= d1[i].size;
            }
            i += 1;
          }
          j += 1;
        }

        while (i < d1.length && j < d2.length) {
          if (d1[i].index < d2[j].index) {
            if (d1[i].type == "Insert") {
              doOldInsert();
            } else if (d1[i].type == "Delete") {
              doOldDelete();
            }
          } else if (d2[j].index < d1[i].index) {
            if (d2[j].type == "Insert") {
              doNewInsert();
            } else if (d2[j].type == "Delete") {
              doNewDelete();
            }
          } else { // must be equal
            if (d1[i].type == "Insert") {
              doOldInsert();
            } else if (d2[j].type == "Insert") {
              doNewInsert();
            } else if (d1[i].type == "Delete") {
              doOldDelete();
            }
          }
        }
        while (j < d2.length) {
          if (d2[j].type == "Insert") {
            doNewInsert();
          } else if (d2[j].type == "Delete") {
            doNewDelete();
          }
        }
        return output;
      }

      // returns the result of applying diff to content
      var applyDiff = function(content, diff) {
        var index = 0;
        var output = "";
        for (var i = 0; i < diff.length; i += 1) {
          var op = diff[i];
          output += content.substring(index, op.index);
          index = op.index
          if (op.type == "Insert") {
            output += op.val;
          } else if (op.type == "Delete") {
            index += op.size;
          }
        }
        output += content.substring(index, content.length);
        return output;
      }

      // get index in window.state.commits of latest commit
      function head() {
        return window.state.commits.length - 1;
      };

      // returns a copy of a simple javascript object
      function copy(x) {
        return JSON.parse(JSON.stringify(x));
      }

      // register periodic syncing
      $(function() {
        var period = 3000;
        setInterval(doCommit, period);
        setTimeout(function() {
          setInterval(doUpdate, period);
        }, period / 2);
      });

    </script>
  </head>
  <body>
    <textarea id="pad" rows="10" cols="40"></textarea>
  </head>
</html5>
